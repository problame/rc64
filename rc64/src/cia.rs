mod backends;
pub(super) mod keyboard;
mod registers;

use crate::interrupt::Interrupt;
pub use backends::PeripheralDevicesBackend;

use crate::mos6510;
use crate::utils::R2C;
use crate::vic20::VIC20;
use std::rc::Rc;

use self::backends::*;
use self::registers::*;

/// 56320-56335   $DC00-$DC0F
/// Complex Interface Adapter (CIA) #1 Registers
///
/// Locations 56320-56335 ($DC00-$DC0F) are used to communicate with the Complex Interface
/// Adapter chip #1 (CIA #1).  This chip is a successor to the earlier VIA and PIA devices used
/// on the VIC-20 and PET.  This chip functions the same way as the VIA and PIA: It allows the
/// 6510 microprocessor to communicate with peripheral input and output devices.  The specific
/// devices that CIA #1 reads data from and sends data to are the joystick controllers, the
/// paddle fire buttons, and the keyboard.
///
/// In addition to its two data ports, CIA #1 has two timers, each of which can count an
/// interval from a millionth of a second to a fifteenth of a second.  Or the timers can be
/// hooked together to count much longer intervals.  CIA #1 has an interrupt line which is
/// connected to the 6510 IRQ line.  These two timers can be used to generate interrupts at
/// specified intervals (such as the 1/60 second interrupt used for keyboard scanning, or the
/// more complexly timed interrupts that drive the tape read and write routines).  As you will
/// see below, the CIA chip has a host of other features to aid in Input/Output functions.
/// 56576-56591    $DD00-$DD0F
/// Complex Interface Adapter (CIA) #2 Registers
///
/// Locations 56576-56591 ($DD00-$DD0F) are used to address the Complex Interface Adapter chip
/// #2 (CIA #2).  Since the chip itself is identical to CIA #1, which is addressed at 56320
/// ($DC00), the discussion here will be limited to the use which the 64 makes of this
/// particular chip.  For more general information on the chip registers, please see the
/// corresponding entries for CIA #1.
///
/// One of the significant differences between CIA chips #1 and #1 is the use to which Data
/// Ports A and B are put.  The peripheral input and output devices that CIA #2 controls are
/// those on the Serial Bus (such as the 1541 Disk Drive and 1525 printer), the RS-232 device
/// (which is used for telecommunications), and the User Port, an eight-bit parallel port that
/// can be turned to whatever purpose the user desires.  In addition, Data Port A has the
/// important task of selecting the 16K bank ofmemory that will be used by the VIC-II chip for
/// graphics.
///
/// Another significant difference between CIA chips #1 and #2 is that the interrupt line of CIA
/// #1 is wired to the 6510 IRQ line, while that of CIA #2 is wired to the NMI line.  This means
/// that interrupts from this chip cannot be masked by setting the Interrupt disable flag (SEI).
/// They can be disabled from CIA's Mask Register, though.  Be sure to use the NMI vector when
/// setting up routines to be driven by interrupts generated by this chip.
pub struct CIA<T> {
    registers: Vec<Rc<dyn Register>>,

    data_port: R2C<DataPortBackend<T>>,
    timer_a: R2C<TimerBackend>,
    timer_b: R2C<TimerBackend>,
    tod: R2C<TimeOfDayBackend>,
}

pub enum CIAKind<T> {
    Chip1 { peripherals: R2C<dyn PeripheralDevicesBackend> },
    Chip2 { vic: R2C<VIC20<T>> },
}

// TODO Remove this 'static
impl<T: 'static> CIA<T> {
    pub fn new(kind: CIAKind<T>) -> Self {
        use CIAKind::*;

        let data_port = match kind {
            Chip1 { peripherals } => r2c_new!(DataPortBackend::CIA1 { peripherals }),
            Chip2 { vic } => r2c_new!(DataPortBackend::CIA2 { vic, serial_bus: SerialBusBackend {}, rs232: RS232Backend {}, userport: UserportBackend {} }),
        };

        let int_be = r2c_new!(InterruptBackend::default());
        let timer_a = r2c_new!(TimerBackend::new(None, int_be.clone()));
        let timer_b = r2c_new!(TimerBackend::new(Some(timer_a.clone()), int_be.clone()));
        let tod = r2c_new!(TimeOfDayBackend::default());
        let ssr = r2c_new!(SerialShiftBackend::default());

        CIA {
            registers: vec![
                Rc::new(DataA(data_port.clone())),
                Rc::new(DataB(data_port.clone())),
                Rc::new(DataDirectionA(data_port.clone())),
                Rc::new(DataDirectionB(data_port.clone())),
                Rc::new(Timer(timer_a.clone(), ByteHalf::Low)),
                Rc::new(Timer(timer_b.clone(), ByteHalf::High)),
                Rc::new(Timer(timer_a.clone(), ByteHalf::Low)),
                Rc::new(Timer(timer_b.clone(), ByteHalf::High)),
                Rc::new(RTClock(tod.clone(), Precision::DeciSeconds)),
                Rc::new(RTClock(tod.clone(), Precision::Seconds)),
                Rc::new(RTClock(tod.clone(), Precision::Minutes)),
                Rc::new(RTClock(tod.clone(), Precision::Hours)),
                Rc::new(SerialShift(ssr)),
                Rc::new(InterruptControl(int_be)),
                Rc::new(ControlTimer(timer_a.clone())),
                Rc::new(ControlTimer(timer_b.clone())),
            ],

            data_port,
            timer_a,
            timer_b,
            tod,
        }
    }

    pub fn cycle(&self) -> Option<Interrupt> {
        self.tod.borrow_mut().cycle().or(self.timer_a.borrow_mut().cycle()).or(self.timer_b.borrow_mut().cycle()).or(self.data_port.borrow_mut().cycle())
    }
}

impl<T> CIA<T> {
    fn get_reg(&self, addr: u16) -> Rc<dyn Register> {
        assert!(addr < 0xff);

        self.registers[(addr % 0x10) as usize].clone()
    }
}

impl<T> mos6510::MemoryArea for CIA<T> {
    fn read(&self, addr: u16) -> u8 {
        self.get_reg(addr).read()
    }

    fn write(&mut self, addr: u16, val: u8) -> mos6510::WriteResult {
        self.get_reg(addr).write(val);
        mos6510::WriteResult::Wrote
    }
}
